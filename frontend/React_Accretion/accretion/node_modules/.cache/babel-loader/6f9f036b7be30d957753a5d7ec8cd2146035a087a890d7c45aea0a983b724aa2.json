{"ast":null,"code":"import { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\"\n// TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n// or until we implement support for linear() easing.\n// \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || options.name === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n}\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  const sampleAnimation = new MainThreadAnimation({\n    ...options,\n    keyframes,\n    repeat: 0,\n    delay: 0\n  });\n  let state = {\n    done: false,\n    value: keyframes[0]\n  };\n  const pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n  let t = 0;\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\nclass AcceleratedAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    const {\n      name,\n      motionValue,\n      keyframes\n    } = this.options;\n    this.resolver = new DOMKeyframesResolver(keyframes, resolvedKeyframes => this.onKeyframesResolved(resolvedKeyframes), name, motionValue);\n    this.resolver.scheduleResolve();\n  }\n  initPlayback(keyframes) {\n    let duration = this.options.duration || 300;\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n    if (requiresPregeneratedKeyframes(this.options)) {\n      const {\n        onComplete,\n        onUpdate,\n        motionValue,\n        ...options\n      } = this.options;\n      const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n      keyframes = pregeneratedAnimation.keyframes;\n      duration = pregeneratedAnimation.duration;\n      this.options.times = pregeneratedAnimation.times;\n      this.options.ease = pregeneratedAnimation.ease;\n    }\n    const {\n      motionValue,\n      name\n    } = this.options;\n    const animation = animateStyle(motionValue.owner.current, name, keyframes, {\n      ...this.options,\n      duration\n    });\n    // Override the browser calculated startTime with one synchronised to other JS\n    // and WAAPI animations starting this event loop.\n    animation.startTime = time.now();\n    if (this.pendingTimeline) {\n      animation.timeline = this.pendingTimeline;\n      this.pendingTimeline = undefined;\n    } else {\n      /**\n       * Prefer the `onfinish` prop as it's more widely supported than\n       * the `finished` promise.\n       *\n       * Here, we synchronously set the provided MotionValue to the end\n       * keyframe. If we didn't, when the WAAPI animation is finished it would\n       * be removed from the element which would then revert to its old styles.\n       */\n      animation.onfinish = () => {\n        const {\n          onComplete\n        } = this.options;\n        motionValue.set(getFinalKeyframe(keyframes, this.options));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n      };\n    }\n    return {\n      animation,\n      duration,\n      keyframes: keyframes\n    };\n  }\n  get duration() {\n    const {\n      duration\n    } = this.resolved;\n    return millisecondsToSeconds(duration);\n  }\n  get time() {\n    const {\n      animation\n    } = this.resolved;\n    return millisecondsToSeconds(animation.currentTime || 0);\n  }\n  set time(newTime) {\n    const {\n      animation\n    } = this.resolved;\n    animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  get speed() {\n    const {\n      animation\n    } = this.resolved;\n    return animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    const {\n      animation\n    } = this.resolved;\n    animation.playbackRate = newSpeed;\n  }\n  get state() {\n    const {\n      animation\n    } = this.resolved;\n    return animation.playState;\n  }\n  /**\n   * Replace the default DocumentTimeline with another AnimationTimeline.\n   * Currently used for scroll animations.\n   */\n  attachTimeline(timeline) {\n    if (!this._resolved) {\n      this.pendingTimeline = timeline;\n    } else {\n      const {\n        animation\n      } = this.resolved;\n      animation.timeline = timeline;\n      animation.onfinish = null;\n    }\n    return noop;\n  }\n  play() {\n    if (this.isStopped) return;\n    const {\n      animation\n    } = this.resolved;\n    animation.play();\n  }\n  pause() {\n    const {\n      animation\n    } = this.resolved;\n    animation.pause();\n  }\n  stop() {\n    this.isStopped = true;\n    const {\n      animation,\n      keyframes\n    } = this.resolved;\n    if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n      return;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    if (this.time) {\n      const {\n        motionValue,\n        onUpdate,\n        onComplete,\n        ...options\n      } = this.options;\n      const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes\n      });\n      motionValue.setWithVelocity(sampleAnimation.sample(this.time - sampleDelta).value, sampleAnimation.sample(this.time).value, sampleDelta);\n    }\n    this.cancel();\n  }\n  complete() {\n    this.resolved.animation.finish();\n  }\n  cancel() {\n    this.resolved.animation.cancel();\n  }\n  static supports(options) {\n    const {\n      motionValue,\n      name,\n      repeatDelay,\n      repeatType,\n      damping,\n      type\n    } = options;\n    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n    /**\n     * If we're outputting values to onUpdate then we can't use WAAPI as there's\n     * no way to read the value from WAAPI every frame.\n     */\n    !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n  }\n}\nexport { AcceleratedAnimation };","map":{"version":3,"names":["time","DOMKeyframesResolver","memo","noop","millisecondsToSeconds","secondsToMilliseconds","BaseAnimation","MainThreadAnimation","animateStyle","isWaapiSupportedEasing","getFinalKeyframe","supportsWaapi","Object","hasOwnProperty","call","Element","prototype","acceleratedValues","Set","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","name","ease","pregenerateKeyframes","keyframes","sampleAnimation","repeat","delay","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","AcceleratedAnimation","constructor","motionValue","resolver","resolvedKeyframes","onKeyframesResolved","scheduleResolve","initPlayback","onComplete","onUpdate","pregeneratedAnimation","animation","owner","current","startTime","now","pendingTimeline","timeline","onfinish","set","cancel","resolveFinishedPromise","updateFinishedPromise","resolved","currentTime","newTime","speed","playbackRate","newSpeed","playState","attachTimeline","_resolved","play","isStopped","pause","stop","setWithVelocity","complete","finish","supports","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"sources":["/Users/yxni-mbp/Dropbox (Personal)/Startup/Accretion/Website/frontend/React_Accretion/accretion/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (options.type === \"spring\" ||\n        options.name === \"backgroundColor\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes) => this.onKeyframesResolved(resolvedKeyframes), name, motionValue);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes) {\n        let duration = this.options.duration || 300;\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            duration = pregeneratedAnimation.duration;\n            this.options.times = pregeneratedAnimation.times;\n            this.options.ease = pregeneratedAnimation.ease;\n        }\n        const { motionValue, name } = this.options;\n        const animation = animateStyle(motionValue.owner.current, name, keyframes, { ...this.options, duration });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = time.now();\n        if (this.pendingTimeline) {\n            animation.timeline = this.pendingTimeline;\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n                this.updateFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { duration } = this.resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { animation } = this.resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { animation } = this.resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { animation } = this.resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { animation } = this.resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { animation } = this.resolved;\n        return animation.playState;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { animation } = this.resolved;\n            animation.timeline = timeline;\n            animation.onfinish = null;\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { animation } = this.resolved;\n        animation.play();\n    }\n    pause() {\n        const { animation } = this.resolved;\n        animation.pause();\n    }\n    stop() {\n        this.isStopped = true;\n        const { animation, keyframes } = this.resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n            });\n            motionValue.setWithVelocity(sampleAnimation.sample(this.time - sampleDelta).value, sampleAnimation.sample(this.time).value, sampleDelta);\n        }\n        this.cancel();\n    }\n    complete() {\n        this.resolved.animation.finish();\n    }\n    cancel() {\n        this.resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}