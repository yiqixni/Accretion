{"ast":null,"code":"import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, removeNonTranslationalTransform, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\nclass DOMKeyframesResolver extends KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue) {\n    super(unresolvedKeyframes, onComplete, name, motionValue, motionValue === null || motionValue === void 0 ? void 0 : motionValue.owner, true);\n  }\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      element,\n      name\n    } = this;\n    if (!element.current) return;\n    const noneKeyframeIndexes = [];\n    super.readKeyframes();\n    /**\n     * If any keyframe is a CSS variable, we need to find its value by sampling the element\n     */\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      const keyframe = unresolvedKeyframes[i];\n      if (typeof keyframe === \"string\" && isCSSVariableToken(keyframe)) {\n        const resolved = getVariableValue(keyframe, element.current);\n        if (resolved !== undefined) {\n          unresolvedKeyframes[i] = resolved;\n        }\n      }\n      if (isNone(unresolvedKeyframes[i])) {\n        noneKeyframeIndexes.push(i);\n      }\n    }\n    if (noneKeyframeIndexes.length) {\n      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n    }\n    /**\n     * Check to see if unit type has changed. If so schedule jobs that will\n     * temporarily set styles to the destination keyframes.\n     * Skip if we have more than two keyframes or this isn't a positional value.\n     * TODO: We can throw if there are multiple keyframes and the value type changes.\n     */\n    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n      return;\n    }\n    const [origin, target] = unresolvedKeyframes;\n    const originType = findDimensionValueType(origin);\n    const targetType = findDimensionValueType(target);\n    /**\n     * Either we don't recognise these value types or we can animate between them.\n     */\n    if (!originType || !targetType || originType === targetType) return;\n    /**\n     * If both values are numbers or pixels, we can animate between them by\n     * converting them to numbers.\n     */\n    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        const value = unresolvedKeyframes[i];\n        if (typeof value === \"string\") {\n          unresolvedKeyframes[i] = parseFloat(value);\n        }\n      }\n    } else {\n      /**\n       * Else, the only way to resolve this is by measuring the element.\n       */\n      this.needsMeasurement = true;\n    }\n  }\n  unsetTransforms() {\n    const {\n      element,\n      name,\n      unresolvedKeyframes\n    } = this;\n    if (!element.current) return;\n    this.removedTransforms = removeNonTranslationalTransform(element);\n    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n    element.getValue(name, finalKeyframe).jump(finalKeyframe, false);\n  }\n  measureInitialState() {\n    const {\n      element,\n      unresolvedKeyframes,\n      name\n    } = this;\n    if (!element.current) return;\n    if (name === \"height\") {\n      this.suspendedScrollY = window.pageYOffset;\n    }\n    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    unresolvedKeyframes[0] = this.measuredOrigin;\n  }\n  renderEndStyles() {\n    this.element.render();\n  }\n  measureEndState() {\n    var _a;\n    const {\n      element,\n      name,\n      unresolvedKeyframes\n    } = this;\n    if (!element.current) return;\n    const value = element.getValue(name);\n    value && value.jump(this.measuredOrigin, false);\n    unresolvedKeyframes[unresolvedKeyframes.length - 1] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    if (name === \"height\" && this.suspendedScrollY !== undefined) {\n      window.scrollTo(0, this.suspendedScrollY);\n    }\n    // If we removed transform values, reapply them before the next render\n    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n      this.removedTransforms.forEach(_ref => {\n        let [unsetTransformName, unsetTransformValue] = _ref;\n        element.getValue(unsetTransformName).set(unsetTransformValue);\n      });\n    }\n  }\n}\nexport { DOMKeyframesResolver };","map":{"version":3,"names":["isNone","getVariableValue","isCSSVariableToken","positionalKeys","isNumOrPxType","removeNonTranslationalTransform","positionalValues","findDimensionValueType","KeyframeResolver","makeNoneKeyframesAnimatable","DOMKeyframesResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","owner","readKeyframes","element","current","noneKeyframeIndexes","i","length","keyframe","resolved","undefined","push","has","origin","target","originType","targetType","value","parseFloat","needsMeasurement","unsetTransforms","removedTransforms","finalKeyframe","getValue","jump","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","renderEndStyles","render","measureEndState","_a","scrollTo","forEach","_ref","unsetTransformName","unsetTransformValue","set"],"sources":["/Users/yxni-mbp/Dropbox (Personal)/Startup/Accretion/Website/frontend/React_Accretion/accretion/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, removeNonTranslationalTransform, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, motionValue === null || motionValue === void 0 ? void 0 : motionValue.owner, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element.current)\n            return;\n        const noneKeyframeIndexes = [];\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            const keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\" && isCSSVariableToken(keyframe)) {\n                const resolved = getVariableValue(keyframe, element.current);\n                if (resolved !== undefined) {\n                    unresolvedKeyframes[i] = resolved;\n                }\n            }\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (!originType || !targetType || originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    unsetTransforms() {\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element.current)\n            return;\n        this.removedTransforms = removeNonTranslationalTransform(element);\n        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        element.getValue(name, finalKeyframe).jump(finalKeyframe, false);\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n    }\n    renderEndStyles() {\n        this.element.render();\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        unresolvedKeyframes[unresolvedKeyframes.length - 1] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (name === \"height\" && this.suspendedScrollY !== undefined) {\n            window.scrollTo(0, this.suspendedScrollY);\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}